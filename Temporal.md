Temporal is a **Durable Execution** platform. It ensures that your code runs to completion, no matter what. If you code is in the middle of a process and the server crashes, the network goes down, or a third-party API fails, Temporal remembers exactly where your code was and resumes it once the issue is resolved.

## The Save Game Analogy
Think of Temporal like a **Video Game Save Point.**

- **Standard Code**: If the power goes out, you lose all progress and have to start the game from the beginning.
- **Temporal Code**: Every time you perform an action, the game *auto-saves*. If the power goes out, you restart exactly where at the last save point with all your items and stats intact.

## The Core Architecture
Temporal consists of three main parts working together.

1. **Temporal Server**: The **Brain**. It maintains a database of your workflow's history. It does **not** run your code; it just tracks the *state*.
2. **Temporal Worker**: The **Muscle**. This is your server running your Python code. It asks the Server, *Is there any work to do?*
3. **Task Queue**: The **Bridge**. It's a dynamic queue where the Server places tasks and Worker picks them up.

## The Four Pillars of Temporal Code
To write a Temporal application, you must define these four components.

#### 1. The Activity
An **Activity** is a function that performs a single, idempotent action. This is where you put *risky* code. 

- **Examples**: Calling a Stripe API, querying a DB, sending an email.
- **Rule**: Activities can fail. Temporal will automatically retry them based on your policy.

#### 2. The Workflow
A **Workflow** is a function that coordinates Activities. It defines the *steps* of your process.

- **The Golden Rule**: A workflow must be **deterministic**. If you run it 100 times with the same input, it must do the exact same thing.
- **Forbidden in Workflows**: `datetime.now()`, `random()`, or global variables. You must use the Temporal's built in versions of these.

#### 3. The Worker
A **Worker** is a process that hosts your Workflow and Activity code.

- It *polls* the **Task Queue** for work.
- You can have 1 worker or 1000 workers; they all listen to the same Task Queue.

#### 4. The Client
You can use a **Client** to *Start* a workflow, *Signal* or workflow, or *Query* its status.

## Key Terminology

| Keyword           | Description                                                                                                         |
| ----------------- | ------------------------------------------------------------------------------------------------------------------- |
| **Workflow ID**   | A unique string you give to a workflow so you can find it later.                                                    |
| **Run ID**        | A unique *UUID* generated by Temporal for a specific execution of a workflow.                                       |
| **Event History** | An immutable log of everything that happened in a workflow *(Started -> Activity Scheduled -> Activity Completed)*. |
| **Replay**        | The process where a Worker re-reads the Event History to rebuild the state of a workflow after a crash.             |
| **Heartbeating**  | A signal sent by a long-running Activity to the Server to say *I'm still alive; don't time me out*.                 |

## Understanding Timeouts
Temporal provides granular control over time. These are the three most important:

1. **Schedule-To-Close**: The *Maximum time I'm willing to wait for this to finish*, including retries.
2. **Start-To-Close**: The *Maximum time a single-attempt should take*. (Useful for detecting if a Worker crashed mid-task).
3. **Workflow Run Timeout**: The total time a Workflow is allowed to exist.


## Communication: Signals and Queries
How do you talk to a workflow that is already running?

#### Signals (Input)
A **Signal** is an external trigger sent to a running workflow. It is **Fire and Forget**.

- **Example**: A 'Cancel Order' button or a 'User Verified Email' event.
  *Workflow Action*: It receives the signal and changes its logic (e.g., stops waiting and proceeds).

#### Queries (Output)
A **Query** is a way to ask a running workflow for its current state.

- **Example**: "What is the current balance?" or "What step are we on?"
  *Workflow Action*: It returns a value immediately without changing its state.


## The Workflow Lifecycle

1. **Client** sends **ExecuteWorkflow** to **Server**.
2. **Server** adds a *Start Workflow* task to the **Task Queue**.
3. **Worker** picks up the task and starts running the **Workflow** code.
4. **Workflow** hits an **Activity** call and tells the **Server**.
5. **Server** adds an **Activity Task** to the **Task Queue**.
6. **Worker** (could be a different one) picks up the **Activity**, runs it, and reports success to the **Server**.
7. **Server** tells the **Workflow** it can continue to the next line.
8. **Repeat** until the Workflow returns a result.


## Building a simple workflow
Initialize a python project in your desired directory. I recommend using `uv`.

Clone the official repository with `docker compose ` files to spin up a local instance of the Temporal Server.

```python
git clone https://github.com/temporalio/docker-compose.git
cd docker-compose
docker compose up -d
```

This is the folder structure I used.
```
├── app
│   ├── activities.py
│   ├── __init__.py
│   ├── run_worker.py
│   ├── run_workflow.py
│   └── workflows.py
├── docker-compose
│   ├── deployment
│   │   ├── grafana
│   │   │   ├── config.ini
...
.....
```

#### 1. The Activity
`activities.py`
```python
from temporalio import activity


@activity.defn
def say_hello(name: str) -> str:
	return f"Hello, {name}!"
```

#### 2. The Workflow
`workflows.py`
```python
from datetime import timedelta

from temporalio import workflow

with workflow.unsafe.imports_passed_through():
    from app.activities import say_hello


@workflow.defn
class SayHello:
    @workflow.run
    async def run(self, name: str) -> str:
        return await workflow.execute_activity(
            say_hello, name, schedule_to_close_timeout=timedelta(seconds=5)
        )
```

#### 3. The Worker
`run_worker.py`
```python
import asyncio
import concurrent.futures

from temporalio.client import Client
from temporalio.worker import Worker

from app.activities import say_hello
from app.workflows import SayHello


async def main():
    client = await Client.connect("localhost:7233")

    with concurrent.futures.ThreadPoolExecutor(max_workers=100) as activity_executor:
        worker = Worker(
            client,
            task_queue="my-task-queue",
            workflows=[SayHello],
            activities=[say_hello],
            activity_executor=activity_executor,
        )
        await worker.run()


if __name__ == "__main__":
    asyncio.run(main())
```

#### 4. The Client (running the workflow)
`run_workflow.py`
```python
import asyncio

from temporalio.client import Client

from app.workflows import SayHello


async def main():
    # Connect to the Temporal server
    client = await Client.connect("localhost:7233")

    # Start the workflow
    result = await client.execute_workflow(
        SayHello.run,
        "Alice",
        id="hello-world-workflow-id-001",
        task_queue="my-task-queue",
    )

    print(f"Workflow result: {result}")


if __name__ == "__main__":
    asyncio.run(main())
```


It can be confusing to understand the difference between `run_worker.py` and `run_workflow.py`.

- `run_worker.py` is like the **Kitchen**. It is the place where the work actually happens. It must stay open (running to accept orders).
- `run_workflow.py` is the **Customer**: It places an order. Once the order is placed, customer can leave or wait for the food.

